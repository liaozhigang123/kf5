动态代理（理解）：基于反射机制

1、掌握程度

    a、什么是动态代理？
        使用jdk反射机制，创建对象的能力，创建是代理类对象。
        而不是你创建类文件。不用写java文件。

        动态：在程序执行时，调用jdk提供的方法才能创建代理类对象。

        jdk动态代理，必须有接口，目标类必须实现接口，没有接口时，需要使用cglib动态代理。

    b、知道动态代理能做什么？
        可以在不改变原来目标方法功能前提下，可以在代理中增强自己的功能代码。

        程序开发中的意义：
            比如：你所在的项目中，有一个功能是其他人（公司的其他部门，其他小组的人）写好的，你可以使用。
            GoNeng.class,   GoNong gn = new GoNong(),   gn.print();

            你发现这个功能，现在还缺点东西，不能完全满足我项目的需要。
            我需要在gn.print()执行后，需要自己在增加代码。
            用代理实现gn.print()调用时，增加自己代码，而不用去改原来的GoNeng文件。

    后面会讲 mybatis,spring 用到

2、使用代理模式的作用

    a、功能增强：在原来的功能上，增加了额外的功能，新增加的功能，叫做功能增强。
    b、控制访问：代理类不让你访问目标，例如商家不让用户直接访问厂家。

3、实现代理的方式
    a、静态代理：
        代理类是自己手工实现的，自己创建一个java类，表示代理类。
        同时你所要代理的目标类是确定的。

        特点：实现简单、容易理解。

        缺点：当你的项目中，目标类和代理类很多的时候，有以下的缺点
            (1)、当目标类增加了，代理类可能也需要成倍的增加，代理类数量过多。
            (2)、当你的接口中功能增加了，或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多。


        模拟一个用户购买U盘的行为。
            用户：是客服端类
            商家：代理，代理某个品牌的U盘。
            厂家：目标类。

            三者的关系：用户（客户端）---商家（代理）---厂家（目标）
            商家和厂家都是卖U盘的，他们完成的功能是一致的，都是卖U盘。

        实现步骤：
            (1)、创建一个接口，定义卖U盘的方法，表示你的厂家和商家做的事情。
            (2)、创建厂家类，实现(1)步骤中的接口。
            (3)、创建商家，就是代理，也需要实现(1)步骤中的接口。
            (4)、创建客户端类，调用商家的方法买一个U盘。

        代理类完成的功能：
            (1)、目标类中方法的调用
            (2)、功能增强

    b、动态代理
        在静态代理中目标类很多的时候，可以使用动态代理，避免静态代理的缺点。
        动态代理中目标类即使很多，(1)、代理类数量可以很少，(2)、当你修改了接口中的方法时，不会影响代理类。

        动态代理：在程序执行过程中，使用jdk的反射机制，创建代理类对象，并动态的指定要代理目标类。
        换句话说：动态代理是一种创建java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。

        在java中，要想创建对象：
            (1)、创建类文件，java文件编译为class    【动态代理可以省去这第(1)步，来创建代理类对象】
            (2)、使用构造方法，创建类对象。


        动态代理的实现：

            (1)、jdk动态代理（理解）：使用java反射包中的类和接口实现动态代理的功能。
                反射包 java.lang.reflect，里面有三个类：InvocationHandler, Method, Proxy。

            (2)、cglib动态代理（了解）：cglib是第三方的工具库，创建代理对象。
                cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中
                重写父类中同名的方法，实现功能的修改。

                因为cglib是继承，重写方法，所以要求目标类不能是final的，方法也不能是final的。
                cglib的要求目标类比较宽松，只要能继承就可以了。cglib在很多的框架中使用，
                比如 mybatis，Spring框架中都有使用。


4、jdk动态代理

    反射，Method类，表示方法。类中的方法。通过Method可以执行某个方法。（回顾反射内容）

    jdk动态代理的实现
        反射包 java.lang.reflect，里面有三个类：InvocationHandler, Method, Proxy。

        (1)、InvocationHandler 接口（调用处理器）：就一个方法invoke()
            invoke()：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中。

                代理类完成的功能：
                    调用目标方法，执行目标方法的功能。
                    功能增强，在目标方法调用时，增加功能。

            方法原型：
                public Object invoke(Object proxy, Method method, Object[] args)

                参数：
                    Object proxy：jdk创建的代理对象，无需赋值。
                    Method method：目标类中的方法，jdk提供method对象的
                    Object[] args：目标类中方法的参数，jdk提供的。

            InvocationHandler 接口：表示你的代理要干什么。

            怎么用：
                <1>、创建类实现接口InvocationHandler
                <2>、重写invoke()方法，把原来静态代理中代理类要完成的功能，写在这里就可以了。


        (2)、Method类：表示方法的，确切的说就是目标类中的方法。
            作用：通过Method可以执行某个目标类的方法。Method.invoke();（这个invoke方法是Method类中的方法，和上面InvocationHandler接口的invoke()方法不一样，只是恰巧同名而已。）
                method.invoke(目标对象,方法的参数)
                例如：Object ret = method.invoke(service2,"李四");

            说明：method.invoke() 就是用来执行目标方法的，等同于静态代理中的下面代码
                // 向厂家发送订单，告诉厂家，我买了U盘，厂家发货
                float price = factory.sell(amount); // 厂家的价格。


        (3)、Proxy类：核心的对象，创建代理对象。之前创建对象都是 new 类的构造方法()
            现在我们是使用Proxy类的方法，代理new的使用。

            方法：静态方法 newProxyInstance()
            作用是：创建代理对象，等同于静态代理中的TaoBao taobao = new TaoBao();

            public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)

            参数：
                <1>、ClassLoader loader 类加载器，负责向内存中加载对象的。使用反射获取对象的ClassLoader
                    例如：类a，  a.getClass().getClassLoader(),  目标对象的类加载器

                <2>、Class<?> interfaces:    接口，目标对象实现的接口，也是反射获取的。

                <3>、InvocationHandler h ：我们自己写的，代理类要完成的功能。

            返回值：就是代理对象



5、实现动态代理的步骤：
    (1)、创建接口，定义目标类要完成的功能
    (2)、创建目标类实现接口
    (3)、创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能
            <1>、调用目标方法
            <2>、增强功能
    (4)、使用Proxy类的静态方法，创建代理对象，并把返回值转为接口类型。












































































