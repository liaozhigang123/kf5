HashMap集合

1、HashMap集合：
    a、HashMap集合底层是哈希表/数列表的数据结构。

    b、哈希表是一个这样的数据结构呢，
        哈希表是一个数组和单向链表的结合体。
        数组：在查询方面效率很高，随机增删方面效率很低。
        单向链表：在随机增删方面效率较高，在查询方面效率较低。
        哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。

2、HashMap集合底层的源代码：
    public class HashMap{

        // HashMap底层实际上就是一个数组。（一维数组）
        Node<K,V>[] table;

        // 静态的内部类HashMap.Node
        static class Node<K,V>{
            final int.hash;     // 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储数组的下标。）
            final k key;        // 存储到Map集合中的那个key
            v value;            // 存储到Map集合中的那个value
            Node<K,V> next;     // 下一个节点的内存地址。
        }
    }
    哈希表/散列表：一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）

3、HashMap集合最主要掌握的是：
    map.put(k,v)
    v = map.get(k)
    以上两个方法的实现原理，是必须掌握的。

4、HashMap集合的key部分特点：
    无序，不可重复。

    为什么无序？
        因为不一定挂到那个单向链表上。

    不可重复是怎么保证的？
        equals方法来保证HashMap集合的key不可重复。
        如果key重复了，value会覆盖。

    放在HashMap集合key部分的元素其实就是放到HashSet集合中了。
    所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法。

5、哈希表HashMap使用不当时无法发挥性能！
    假设将所有的hashCode()方法返回值固定为某一个值，那么会导致底层哈希表变成了
    纯单向链表。这种情况我们成为：散列分布不均匀。

    什么是散列分布均匀？
        假设有100个元素，10个单向链表，那么每一个单向链表上有10个节点，这是最好的，
        是散列分布均匀的。

    假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？
        不行，因为这样的话导致底层哈希表就称为一维数组了，没有链表的概念了。
        也是散列分布不均匀。

    散列分布均匀需要你重写hasCode()方法时有一定的技巧。


6、重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，
    需要同时重写hashCode和equals方法。

7、HashMap集合的默认初始化容量是16，默认加载因子是0.75
    这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。

    重点，记住：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的，
    这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。


8、HashMap集合中向Map集合存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！
    equals方法可能调用，也可能不调用。

    拿put(k,v)举例，什么时候equals不会调用？
        k.hashCode()方法返回哈希值，
        哈希值经过哈希算法转换成数组下标。
        数组下标位置上如果null，equals不需要执行。

    拿get(k)举例，什么时候equals不会调用？
        k.hashCode()方法返回哈希值，
        哈希值经过哈希算法转换成数组下标。
        数组下标位置上如果null，equals不需要执行。

9、HashMap集合中注意：
    如果一个类的equals方法重写了，那么hashCode()方法必须重写。
    并且equals方法返回值如果是true，hashCode()方法返回值必须一样。
    equals方法返回true表示两个对象相同，在同一个单向链表上比较。
    那么对于同一个单向链表上节点来说，他们的哈希值都是相同的。
    所以hashCode()方法的返回值也应该相同。

10、hashCode方法和equals方法直接使用IDEA工具生成，但是两个方法需要同时生成。

11、终极结论：
    放在HashMap集合key部分的，以及放在HashSet集合中的元素，需要同时重写hashCode方法和equals方法。

12、在JDK8之后，如果哈希表单向链表的中元素超过8个，单向链表这种数据结构会变成好黑树数据结构。
    当红黑树上的节点数量小于6时，会重新把红黑树变成单向链表数据结构。
    这种方式也是为了提高检索效率，二叉树的检索会再次缩小扫描范围。提高效率。

13、对于哈希表数据结构来说：
    如果o1和o2的hash值相同，一定是放到相同一个单向链表上。
    当然如果o1和o2的hash值不同，但由于哈希算法执行结果之后转换的数组下标可能相同，
    此时会发生“哈希碰撞”。

14、HashMap扩容：
    扩容是：扩容之后的容量是原容量的2倍。

15、HashMap集合key部分允许null吗？
    允许
    但是要注意：HashMap集合的key，null值只能为一个。

16、HashSet集合初始化容量16，初始化容量建议是2的倍数。（HashSet底层是HashMap）
    扩容：扩容之后是原容量的2倍。
